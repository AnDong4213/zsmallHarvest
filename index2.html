<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
    <title>React App</title>
	<style>
		#root {width: 100px;height: 100px;background: pink;}
	</style>
  </head>
  <body>
    <div id="root">
		
	</div>
		<script>
		
			function getMonthDay(year, month) {
			  let days = new Date(year, month, 0).getDate()
			  return days
			}
			console.log(getMonthDay(2019,02,0))
			
			function daysJian(day){
			  var date = new Date();//获取当前时间
			  date.setDate(date.getDate() - day);//设置天数 -1 天
			  // var time = date.Format("yyyy-MM-dd");
			  console.log(date);
			  console.log(new Date())
			}
			daysJian(1);
			
			
			// regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null(不管有没有g)。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。
			let aa = "hello world's China";
			// console.log(aa[1])
			/* let result = aa.split(' ').map(item => {
				return item.split('').reverse().join('')
			})
			console.log(result.join(' ')); */
			// console.log(aa.split(/\s/g))
			// console.log(aa.match(/[\w\']+/g))  // ["hello", "world's", "China"]
			
			var str="看24cTheeh rain in SPAIN stays mainly in the plain_c";
			// var n=str.match(/ain/g);  // ["ain", "ain", "ain"]
			var n=str.match(/ain/);  
			// console.log(n)
			
			//console.log(str.match(/[abc]/g)) // ["c", "a", "a", "a", "a", "c"] 与[abc]里的顺序无关...
			// console.log(str.match(/(in|ly)/g))  // ["in", "in", "in", "ly", "in", "in"]
			// console.log(str.match(/[A-Z]|[a-z]/g))  // 无_
			// console.log(str.match(/[A-z]/g)) // 有_
			// console.log(str.match(/\W/g)) // (9) ["看", " ", " ", " ", " ", " ", " ", " ", " "]
			// console.log(str.match(/\d/g))  // 查找数字。
			// console.log(str.match(/e{2}h/g)) // ["eeh"]
			// console.log(str.match(/a?i/g))
			// console.log(str.match(/\w/g))
			
			
			
			let bb = "00110011";
			function countBinarySubstrings(str) {
				  let r = []
				  // 给定任意子输入都返回第一个符合条件的子串
				  let match = (a) => {
					let j = a.match(/^(0+|1+)/)[0]
					let o = (j[0] ^ 1).toString().repeat(j.length)
					let reg = new RegExp(`^(${j}${o})`)
					if (reg.test(a)) {
					  return RegExp.$1
					} else {
					  return ''
					}
				  }
				  // 通过for循环控制程序运行的流程
				  for (let i = 0, len = str.length - 1; i < len; i++) {
					let sub = match(str.slice(i))
					if (sub) {
					  r.push(sub)
					}
				  }
				  return r
				  /* match(str)
				  for (let i = 0, len = str.length - 1; i < len; i++) {
					console.log(str.slice(i))
				  } */
			}
			console.log(countBinarySubstrings(bb))
			
			var countBinarySubstrings2 = function(s) {
				// pre 前一个数字连续出现的次数，cur 当前数字连续出现的次数，result 结果子串个数
				let pre = 0, cur = 1, result = 0
				for (let i = 0; i < s.length - 1; i++) {
					// 判断当前数字是否与后一个数字相同
					if (s[i] === s[i+1]) { // 相同，则当前数字出现的次数cur加1
						cur++ 
					} else { // 不同，则当前数字事实上变成了前一个数字，当前数字的次数重置为1
						pre = cur
						cur = 1
					}
					if (pre >= cur) { // 前一个数字出现的次数 >= 后一个数字出现的次数，则一定包含满足条件的子串
						result++
					}
				}
				return result
			};
			console.log(countBinarySubstrings2('00110011'))
			// console.log(countBinarySubstrings2('00110'))
			console.log(countBinarySubstrings2('00110'))
			
			let gharr = ["h","e","l","l","o","Y"];
			let reverseString = (s) => {
				let test;
				for(let i=0;i<Math.floor(s.length/2);i++){
					test=s[i];
					s[i]=s[s.length-1-i];
					s[s.length-1-i]=test;
				}
				return s
			};
			console.log(reverseString(gharr))
			
			// eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。
            // 如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。
			// eval("console.log('zhao')")
			// document.write(eval('99+1'))
			console.log(window.indexedDB)
			/*s-maxage指定缓存的有效时间，只能指定public的缓存，优先级高于max-age的，缓存设备有很多，不仅仅浏览器是缓存设备，对于整个网络来说，还有可能在服务器和客户端中间有我们的代理服务器，也可能作为我们的缓存设备，比如说CDN就有可能作为我们的缓存设备。对于这样的缓存设备分两种情况，一种是private缓存设备就是私人的缓存设备，比如客户端浏览器所缓存的信息，只有访问这个浏览器的用户才能使用，还有一种就是public设备的缓存，比如CDN,能被很多用户访问并读取信息的。
			s-maxage对于CDN这样公共的缓存区域，在s-maxage所设置的过期时间之内，缓存是不会过期的，只有超过了设置的过期时间，CDN才会向相应的源服务器去更新最新的文件，会起个回源的动作，回源的动作是通过s-maxage配置来触发的*/
			
			/*no-cache当前文件都会向服务器发起请求，去服务器那边去询问我的这个缓存文件有没有在缓存策略里过期(比如last-modified)，而不是不发请求直接去浏览器的缓存里读*/
			
			// 强的浏览器端的缓存策略，不会触发任何的向服务端发起请求的过程，而是直接从浏览器中读取相应缓存的数据
		/*var obj1 = {
		  'name': 'zhangsan',
		  'age': '13',
		  'language': [1,8]
		};
		function iterate(obj) {
			var arr = [];
			//用for in 对obj对象的属性进行遍历
			for(var key in obj){
				if (obj.hasOwnProperty(key)){                 //hasOwnproperty返回对象实例中的属性
					arr.push(key + ": " + obj[key]);
				}
			}
			return arr;
		}
		console.log(iterate(obj1));
		console.log(Object.getOwnPropertyNames(obj1))*/
		
			
		let root = document.getElementById('root');
		
		/*var i = 0;
		function time(){  //每隔1秒让++i
			console.log(++i);
			setTimeout(time,1000);
		}
		time(); //执行time函数	
		
		root.onclick = function() {
			time = null
		}*/
		
		let flag = true;
		var i = 0;
		let set = function() {
			setTimeout(function(){
				if (flag) {
					console.log(++i)
					flag = false
					set();
				} else {
					flag = true
					set()
				}
			}, 1000)
		}
		// set();
		root.onclick = function() {
			// set = null;
			clearTimeout(set)
			return;
		}
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
			
			
			
  
		</script>
  </body>
</html> 