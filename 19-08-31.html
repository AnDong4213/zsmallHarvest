<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="theme-color" content="#000000">
	<title>React App</title>
</head>

<body>
	<div style="width: 200px;height: 200px;background: #ccc;" id="dropbox"></div>
	<script>
		/* const box = {x: 10, y: 20, z: {a: 2}};
		Object.freeze(box);

		const shape = box;
		shape.x = 100;
		shape.z.a = 100;
		console.log(box);  // z: {a: 100} 改变了    //  Object.freeze使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。
		console.log(shape)

		console.log(Object.isFrozen(shape)); */ // true

		/* const { name: myName } = { name: "Lydia" };
    console.log(name === '');  //  true
    console.log(myName); */ // Lydia

		/* const add = () => {
			const cache = {};
			return num => {
				if (num in cache) {
					return `From cache! ${cache[num]}`;
				} else {
					const result = num + 10;
					cache[num] = result;
					return `Calculated! ${result}`;
				}
			};
			};
			const addFunction = add();
			console.log(addFunction(10));
			console.log(addFunction(10));
			console.log(addFunction(5 * 2)); */
		/* Calculated! 20
      From cache! 20
			From cache! 20 */

		const myLifeSummedUp = ["☕", "💻", "🍷", "🍫"]
		/* for (let item in myLifeSummedUp) {
			console.log(item)
		} */
		/* for (let item of myLifeSummedUp) {
			console.log(item)
		}; */
		/* 通过 for-in循环，我们可以遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。在数组中，可枚举属性是数组元素的“键”， 即它们的索引。类似于下面这个对象：
		{0:"☕",1:"💻",2:"🍷",3:"🍫"}
		其中键则是可枚举属性，因此 0， 1， 2， 3被记录。
		通过 for-of循环，我们可以迭代可迭代对象（包括 Array， Map， Set， String， arguments等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量 item, 因此 “☕”， “💻“， ”🍷”， “🍫“被打印。 */

		/* function sayHi(name) {
			return `${name}`
		}
		console.log(sayHi() === 'undefined') */ // true

		// console.log("I want pizza"[0])  // 'I'
		/* function sum(num1, num2 = num1) {
			console.log(num1 + num2) 
		}
		// sum(10)  // 20
		sum()  // NaN */

		function test(m = n, n = 2) {
			console.log(m, n)
		}
		// test();  // Cannot access 'n' before initialization
		// test(3);  // 3 2
		/* let newList = [1, 2, 3]
		console.log(newList.push(34)); //  4
		console.log(newList); // [1, 2, 3, 34] */

		/* const person = {
			name: "Lydia",
			age: 21
		}
		console.log(Object.entries(person)) // [['name'，'Lydia']，['age'，21]]
		console.log(Object.keys(person)); // ["name", "age"]
		console.log(Object.values(person)); // ["Lydia", 21]
		for (const [x, y] of Object.entries(person)) {
			console.log(x, y)
		} */

		/* function nums(a, b) {
			if (a > b)
				console.log('a is bigger')
			else
				console.log('b is bigger')
			return
			a + b
		} // 自动分号插入
		console.log(nums(4, 2))
		console.log(nums(1, 2)) */

		/* class Person {
			constructor() {
				this.name = "Lydia"
			}
		}
		Person = class AnotherPerson {
			constructor() {
				this.name = "Sarah"
			}
		}
		const member = new Person()
		console.log(member.name) */
		// 我们可以将类设置为等于其他类/函数构造函数。在这种情况下，我们将 Person设置为 AnotherPerson。这个构造函数的名字是 Sarah，所以新的 Person实例 member上的name属性是 Sarah。

		/* const info = {
			[Symbol('a')]: 'b',
			[Symbol('h')]: 99,
			c: 88
		}
		console.log(info); // {c: 88, Symbol(a): "b", Symbol(h): 99}
		console.log(Object.getOwnPropertySymbols(info)); // [Symbol(a), Symbol(h)]
		console.log(Object.keys(info)); */ // ["c"]

		/* const getUser = user => ({
			name: user.name,
			age: user.age
		});
		const user = {
			name: "Lydia",
			age: 21
		};
		console.log(getUser(user)); */ // getUser函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值!下

		/* const name = "Lydia"
		console.log(name()); */ //  TypeError: name is not a function
		// console.log(s); // ReferenceError: s is not defined

		const output = `${[] && 'Im'}possible! You should${'' && `n't`} see a therapist after so much JavaScript lol`
		console.log(output)
		
		console.log(new Array(26)); // (26) [empty × 26]
		console.log(Array.from(new Array(26)));  // [26个undefined]
		const alphabet = Array.from(new Array(26), (ele, index) => {
			return String.fromCharCode(65 + index)
		})
		console.log(alphabet)
	</script>
</body>

</html>